import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class PFMIoS {
    PFIT P = new PFIT();

    
    public void ADDTRANS(PFITNode nX,int US ,UncertainDatabase database, double minisup, double miniprob) {
        List<String> value = database.name1.get(database.name1.size() - 1);
        List<Double> prob = database.prob1.get(database.prob1.size() - 1);
        HashMap<List<String>, List<Double>> checkoriginal = new HashMap<>();
        List<PFITNode> nodes = new ArrayList<>();
        HashMap<List<String>, List<Double>> checkupdate = new HashMap<>();
        System.out.println(US);
        if (nX.getChildren() == null) {
            return;
        }
        
        for (PFITNode nY: nX.getChildren()) {
            List<Double> Original = new ArrayList<>();
            List<Double> Update = new ArrayList<>();

            Original.add(nY.getLB());
            Original.add(nY.getUB());
            Original.add(nY.getProb());
            checkoriginal.put(nY.getItems(), Original);

            double lb = nY.getLB();
            double ub = nY.getUB();
            double pr = nY.getProb();

            List<List<String>> a = new ArrayList<>();
            List<List<Double>> b = new ArrayList<>();
            a.add(value);
            b.add(prob);
            if (nY.isSingleElementSubset(nY.getItems(), value)){
                nY.setSupport(nY.getSupport() + nY.Supporteds(nY.getItems(),a));
                nY.setExpSup(nY.getExpSup()+nY.ExpSups(nY.getItems(),a,b));
                lb = nY.LBs(nY.ExpSups(nY.getItems(),a,b), miniprob) + nY.getLB();
                ub = nY.UBs(nY.ExpSups(nY.getItems(),a,b), miniprob, nY.Supporteds(nY.getItems(),a)) + nY.getUB();
                if (minisup >= lb && minisup <= ub) {
                    pr = nY.ProbabilityFrequents(nY.getItems(), miniprob,database.name1,database.prob1);
                    // pr = nY.Probability(nY.getSupport(), nY.getExpSup(), miniprob);
                }
            }
            Update.add(lb);
            Update.add(ub);
            Update.add(pr);
            checkupdate.put(nY.getItems(), Update);
            nY.setLB(lb);
            nY.setUB(ub);
            nY.setProb(pr);

        }
        
        for (PFITNode nY : nX.getChildren()) {
            
            if (nY.checkNewFrequent(nY.getItems(),checkoriginal, checkupdate, minisup)){
                List<PFITNode> nZs = nY.getRightSiblings();
                for (PFITNode nZ : nZs){
                    PFITNode child = nY.generateChildNode(nZ);
                    nY.addChild(child);
                    nodes.add(child);
                    child.setSupport(child.Supporteds(child.getItems(),database.name1));
                    child.setExpSup(child.ExpSups(child.getItems(),database.name1,database.prob1));
                    child.LBs(nY.getExpSup(), miniprob);
                    child.UBs(nY.getExpSup(), miniprob, child.getSupport());
                    if (minisup >= child.getLB() && minisup <= child.getUB()) {
                        child.setProb(child.ProbabilityFrequents(child.getItems(), miniprob,database.name1,database.prob1));
                        // pr = child.Probability(child.getSupport(), child.getExpSup(), miniprob);
                    }
                }
            }
            if (nY.checkFrequent(nY.getItems(),checkoriginal, checkupdate, minisup) && nY.isSingleElementSubset(nY.getItems(), value) ){                    
                List<PFITNode> nZs = nY.getRightSiblings();
                for (PFITNode nZ : nZs){
                    if (nZ.checkNewFrequent(nZ.getItems(),checkoriginal, checkupdate, minisup)){
                        PFITNode child = nY.generateChildNode(nZ);
                        nodes.add(child);
                        nZ.addChild(child);
                        child.setSupport(child.Supporteds(child.getItems(),database.name1));
                        child.setExpSup(child.ExpSups(child.getItems(),database.name1,database.prob1));
                        child.LBs(child.getExpSup(), miniprob);
                        child.UBs(child.getExpSup(), miniprob, child.getSupport());
                        if (minisup >= child.getLB() && minisup <= child.getUB()) {
                            child.setProb(child.ProbabilityFrequents(child.getItems(), miniprob,database.name1,database.prob1));
                            // child.setProb(child.Probability(nY.getSupport(), nY.getExpSup(), miniprob));
                        }
                    }
                }
            }
        }
        nX.getChildren().addAll(nodes);
    }
    


    public void DelTran(PFITNode nX, int US, UncertainDatabase database, double minisup, double miniprob) {
        // Lấy danh sách và danh sách xác suất từ cơ sở dữ liệu
        List<String> list = database.name1.get(0);
        List<Double> list1 = database.prob1.get(0);
        HashMap<List<String>, List<Double>> checkoriginal = new HashMap<>();

        HashMap<List<String>, List<Double>> checkupdate = new HashMap<>();

        if (nX.getChildren().isEmpty()) {
            return;
        }
        // Loại bỏ danh sách và danh sách xác suất khỏi cơ sở dữ liệu
        database.name1.remove(0);
        database.prob1.remove(0);
    
        // Tạo danh sách a và b từ list và list1 để sử dụng lại trong vòng lặp
        
        // Lặp qua các nút con của nX
        for (PFITNode nY : nX.getChildren()) {
            List<Double> Original = new ArrayList<>();
            List<Double> Update = new ArrayList<>();

            Original.add(nY.getLB());
            Original.add(nY.getUB());
            Original.add(nY.getProb());
            checkoriginal.put(nY.getItems(), Original);


            double lb = nY.getLB();
            double ub = nY.getUB();
            double pr = nY.getProb();

            List<List<String>> a = new ArrayList<>();
            List<List<Double>> b = new ArrayList<>();
            a.add(list);
            b.add(list1);
    
            if (nX.isSingleElementSubset(nY.getItems(), list)) {
                // Thực hiện các tính toán mà không cần truy cập vào cơ sở dữ liệu
                nY.setSupport(nY.getSupport() - nY.Supporteds(nY.getItems(), a));
                nY.setExpSup(nY.getExpSup() - nY.ExpSups(nY.getItems(), a, b));
                lb =nY.getLB()- nY.LBs(nY.ExpSups(nY.getItems(), a, b), miniprob);
                ub =nY.getUB() -  nY.UBs(nY.ExpSups(nY.getItems(), a, b), miniprob, nY.Supporteds(nY.getItems(), a));
                if (minisup >= lb && minisup <= ub) {
                    pr = nY.ProbabilityFrequents(nY.getItems(), miniprob,database.name1, database.prob1);
                    // pr =  nY.Probability(nY.getSupport(), nY.getExpSup(), miniprob);

                }
            }
            Update.add(lb);
            Update.add(ub);
            Update.add(pr);
            checkupdate.put(nY.getItems(), Update);
            nY.setLB(lb);
            nY.setUB(ub);
            nY.setProb(pr);

        }

        for (PFITNode nY : new ArrayList<>(nX.getChildren())){
            if (nY.checkInfrequent(nY.getItems(),checkoriginal,checkupdate, minisup)) {
                nX.getChildren().removeAll(nY.getChildren());
            }
            if (nY.checkFrequenDel(nY.getItems(),checkoriginal,checkupdate, minisup) && nX.isSingleElementSubset(nY.getItems(), list)) {
                List<PFITNode> nZs = nY.getRightSiblings();
                for (PFITNode nZ : nZs) {
                    if (nZ.checkInfrequent(nZ.getItems(),checkoriginal,checkupdate, minisup)){
                        PFITNode child = nY.generateChildNode(nZ);
                        nY.getChildren().remove(child);
                    }
                }
            }
        }
    }
    
}
