// public double Supporteds(List<String> requiredItems) {
    //     return database.transactionLists.stream()
    //             .filter(a -> a.uncertainItemset.uncertainitem.stream().map(t -> t.name).collect(Collectors.toList()).containsAll(requiredItems))
    //             .count();
    // }
    // public double Supporteds(List<String> requiredItems, List<List<String>> name1) {
        
    //     return name1.stream().filter(transaction -> transaction.containsAll(requiredItems))
    //     .count();
    // }

    // public double ExpSups(List<String> requiredItems ) {
    //     return batch.stream()
    //             .filter(a -> a.uncertainItemset.uncertainItems.stream().map(t -> t.name).collect(Collectors.toList()).containsAll(requiredItems))
    //             .mapToDouble(transaction ->
    //                     transaction.uncertainItemset.uncertainItems.stream()
    //                             .filter(t -> requiredItems.contains(t.name))
    //                             .mapToDouble(t -> t.probability)
    //                             .reduce(1, (acc, probability) -> acc * probability)
    //             )
    //             .sum();
    // }

    // public double ExpSups(List<String> requiredItems, List<List<String>> name1, List<List<Double>> prob1) {
    //     return IntStream.range(0, name1.size())
    //         .filter(i -> {
    //             List<String> transactionItemNames = name1.get(i);
    //             return transactionItemNames.containsAll(requiredItems);
    //         })
    //         .mapToDouble(i -> {
    //             double transactionProbability = IntStream.range(0, requiredItems.size())
    //                     .mapToDouble(j -> {
    //                         int index = name1.get(i).indexOf(requiredItems.get(j));
    //                         return (index != -1) ? prob1.get(i).get(index) : 1.0;
    //                     })
    //                     .reduce(1, (acc, probability) -> acc * probability);

    //             return transactionProbability;
    //         })
    //         .sum();
    // }

    // public double ProbabilityFrequents(List<String> requiredItems, double minValue) {
    //     return batch.stream()
    //         .filter(transaction -> transaction.uncertainItemset.uncertainItems.stream()
    //                 .map(t -> t.name)
    //                 .collect(Collectors.toList())
    //                 .containsAll(requiredItems))
    //         .mapToDouble(transaction ->
    //                 transaction.uncertainItemset.uncertainItems.stream()
    //                         .filter(t -> requiredItems.contains(t.name) && t.probability >= minValue)
    //                         .mapToDouble(t -> t.probability)
    //                         .reduce(1, (acc, probability) -> acc * probability)
    //         )
    //         .count();
    // }

    // public double ProbabilityFrequents(List<String> requiredItems, double minValue, List<List<String>> name1, List<List<Double>> prob1) {
    //     return IntStream.range(0, name1.size())
    //             .filter(i -> name1.get(i).containsAll(requiredItems))
    //             .mapToDouble(i ->
    //                     prob1.get(i).stream()
    //                             .filter(probability -> requiredItems.contains(name1.get(i).get(prob1.get(i).indexOf(probability))) && probability >= minValue)
    //                             .reduce(1.0, (acc, probability) -> acc * probability)
    //             )
    //             .filter(result -> result > 0)  // Consider only transactions with non-zero probability
    //             .count();
    // }


    // public double LBs(List<String> requiredItems, double value) {
    //     double expSups = ExpSups(requiredItems);
    //     double sqrtTerm = Math.sqrt(-2 * expSups * Math.log(1 - value));
    
    //     double maxLB = database.getTransactionLists().stream()
    //         .filter(a -> a.uncertainItemset.uncertainitem.stream().anyMatch(t -> requiredItems.contains(t.name)))
    //         .mapToDouble(t -> Math.round((expSups - sqrtTerm) * 10.0) / 10.0)
    //         .max()
    //         .orElse(0.0);
    
    //     return Math.max(maxLB, 0);
    // }
    // public double LBs(List<String> requiredItems, double value) {
    //     double expSups = ExpSups(requiredItems);
    //     double sqrtTerm = Math.sqrt(-2 * expSups * Math.log(1 - value));
    
    //     double maxLB = IntStream.range(0, database.name.size())
    //             .filter(i -> database.name.get(i).stream().anyMatch(t -> requiredItems.contains(t)))
    //             .mapToDouble(i -> Math.round((expSups - sqrtTerm) * 10.0) / 10.0)
    //             .max()
    //             .orElse(0.0);
    
    //     return Math.max(maxLB, 0);
    // }

      // public double UBs(List<String> requiredItems, double value) {
    //     double expSups = ExpSups(requiredItems);
    //     double logValue = Math.log(value);
    //     double sqrtTerm = Math.sqrt(Math.pow(logValue, 2) - 8 * expSups * logValue);
    
    //     OptionalDouble optionalMax = database.getTransactionLists().stream()
    //             .filter(a -> a.uncertainItemset.uncertainitem.stream().anyMatch(t -> requiredItems.contains(t.name)))
    //             .mapToDouble(t -> Math.round(((2 * expSups - logValue + sqrtTerm) / 2) * 10.0) / 10.0)
    //             .max();
    
    //     double v = optionalMax.orElse(0.0); // Giả sử 0.0 là giá trị mặc định phù hợp
    //     return Math.min(v, Supporteds(requiredItems));
    // }

    // public double UBs(List<String> requiredItems, double value) {
    //     double expSups = ExpSups(requiredItems);
    //     double logValue = Math.log(value);
    //     double sqrtTerm = Math.sqrt(Math.pow(logValue, 2) - 8 * expSups * logValue);
    
    //     OptionalDouble optionalMax = IntStream.range(0, database.name.size())
    //             .filter(i -> database.name.get(i).stream().anyMatch(t -> requiredItems.contains(t)))
    //             .mapToDouble(i -> Math.round(((2 * expSups - logValue + sqrtTerm) / 2) * 10.0) / 10.0)
    //             .max();
    
    //     double v = optionalMax.orElse(0.0); // Giả sử 0.0 là giá trị mặc định phù hợp
    //     return Math.min(v, Supporteds(requiredItems));
    // }
    